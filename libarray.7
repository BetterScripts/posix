.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "libarray" "7" "" "BetterScripts" "Array emulation for POSIX.1 shells."
.hy
.SS LIBARRAY
.SS SYNOPSIS
.PP
\f[V]array_value <VALUE>\f[R]
.PP
\f[V]array_new [--reverse|--reversed|-r] <ARRAY> [<VALUE>...]\f[R]
.PP
\f[V]array_size <ARRAY> [<OUTPUT>]\f[R]
.PP
\f[V]array_get <ARRAY> <INDEX> [<OUTPUT>]\f[R]
.PP
\f[V]array_set <ARRAY> <INDEX> <VALUE>\f[R]
.PP
\f[V]array_insert <ARRAY> <INDEX> <VALUE>...\f[R]
.PP
\f[V]array_remove <ARRAY> [<PRIMARY>] <EXPRESSION>\f[R]
.PP
\f[V]array_push <ARRAY> [<VALUE>...]\f[R]
.PP
\f[V]array_pop <ARRAY> <OUTPUT>\f[R]
.PP
\f[V]array_unshift <ARRAY> [<VALUE>...]\f[R]
.PP
\f[V]array_shift <ARRAY> <OUTPUT>\f[R]
.PP
\f[V]array_reverse <ARRAY> [<OUTPUT>]\f[R]
.PP
\f[V]array_slice <ARRAY> <RANGE> [<OUTPUT>]\f[R]
.PP
\f[V]array_sort <ARRAY> [<OUTPUT>] [--] [<ARGUMENT>...]\f[R]
.PP
\f[V]array_search <ARRAY> [<INDEX>] [<PRIMARY>] <EXPRESSION>\f[R]
.PP
\f[V]array_contains <ARRAY> [<PRIMARY>] <EXPRESSION>\f[R]
.PP
\f[V]array_join <ARRAY> <DELIM> [<OUTPUT>]\f[R]
.PP
\f[V]array_split [<ARRAY>] <TEXT> <SEPARATOR>\f[R]
.PP
\f[V]array_printf <ARRAY> <FORMAT>\f[R]
.PP
\f[V]array_from_path [--all|-a] [<ARRAY>] <DIRECTORY>\f[R]
.PP
\f[V]array_from_find [<ARRAY>] [--] [<ARGUMENT>...]\f[R]
.PP
\f[V]array_from_find_allow_print <ARRAY> [<DESC>] [--] [<ARGUMENT>...]\f[R]
.PP
\f[I]Full synopsis, description, arguments, examples and other
information is\f[R] \f[I]documented with each individual command.\f[R]
.SS DESCRIPTION
.PP
Provides commands to allow any \f[I]POSIX.1\f[R] compliant shell to use
emulated arrays with all common array operations supported.
.SS EXIT STATUS
.IP \[bu] 2
For all commands the exit status will be \f[V]0\f[R] (\f[V]<zero>\f[R])
if, and only if, the command was completed successfully.
.IP \[bu] 2
For any command which is intended to perform a test, an exit status of
\f[V]1\f[R] (\f[V]<one>\f[R]) indicates \[lq]false\[rq], while
\f[V]0\f[R] (\f[V]<zero>\f[R]) indicates \[lq]true\[rq].
.IP \[bu] 2
An exit status that is NOT \f[V]0\f[R] (\f[V]<zero>\f[R]) from an
external command will be propagated to the caller where relevant (and
possible).
.IP \[bu] 2
For any usage error (e.g.\ an unsupported variable name), the
\f[V]EX_USAGE\f[R] error code from FreeBSD
\f[V]SYSEXITS(3)\f[R] (https://www.freebsd.org/cgi/man.cgi?sysexits(3))
is used.
.IP \[bu] 2
Configuration SHOULD NOT change the value of any exit status.
.SS ENVIRONMENT
.PP
A number of environment variables affect the library, these are split
into variables that instruct the library to work-around specific
platform issues, and variables that convey user preferences.
Variables that enable platform specific work-arounds will be
automatically set if needed, but can also be set manually to force
specific configurations.
.PP
In additional to these, there are a number of variables that are set by
the library to convey information outside of command invocation.
.PP
If unset, some variables will take an initial value from a
\f[I]BetterScripts\f[R] \f[I]POSIX Suite\f[R] wide variable, these allow
the same configuration to be used by all libraries in the suite.
.PP
After the library has been sourced, external commands must not set
library environment variables that are classified as CONSTANT.
Variables may use the \f[V]readonly\f[R] command to enforce this.
.PP
\f[B]\f[BI]If not otherwise specified, an \f[VBI]<unset>\f[BI] variable
is equivalent to the\f[B]\f[R] \f[B]\f[BI]default value.\f[B]\f[R]
.PP
\f[I]For more details see the common suite documentation.\f[R]
.SS PLATFORM CONFIGURATION
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_CONFIG_NO_Z_SHELL_SETOPT\f[R]
.IP \[bu] 2
Suite: \f[V]BETTER_SCRIPTS_CONFIG_NO_Z_SHELL_SETOPT\f[R]
.IP \[bu] 2
Type: FLAG
.IP \[bu] 2
Class: CONSTANT
.IP \[bu] 2
Default: <automatic>
.IP \[bu] 2
[Disable]/Enable using \f[V]setopt\f[R] in \f[I]Z Shell\f[R] to ensure
\f[I]POSIX.1\f[R] like behavior.
.IP \[bu] 2
Automatically enabled if \f[I]Z Shell\f[R] is detected.
.IP \[bu] 2
Any use of \f[V]setopt\f[R] is scoped as tightly as possible and SHOULD
not affect other commands.
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_CONFIG_NO_MULTIDIGIT_PARAMETER\f[R]
.IP \[bu] 2
Suite: \f[V]BETTER_SCRIPTS_CONFIG_NO_MULTIDIGIT_PARAMETER\f[R]
.IP \[bu] 2
Type: FLAG
.IP \[bu] 2
Class: CONSTANT
.IP \[bu] 2
Default: <automatic>
.IP \[bu] 2
[Disable]/Enable using only single digit shell parameters,
i.e.\ \f[V]$0\f[R] to \f[V]$9\f[R].
.IP \[bu] 2
\f[I]OFF\f[R]: Use multi-digit shell parameters.
.IP \[bu] 2
\f[I]ON\f[R]: Use only single-digit shell parameters.
.IP \[bu] 2
Multi-digit parameters are faster but may not be supported by all
implementations.
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_CONFIG_NO_SHIFT_N\f[R]
.IP \[bu] 2
Suite: \f[V]BETTER_SCRIPTS_CONFIG_NO_SHIFT_N\f[R]
.IP \[bu] 2
Type: FLAG
.IP \[bu] 2
Class: CONSTANT
.IP \[bu] 2
Default: <automatic>
.IP \[bu] 2
[Disable]/Enable using only \f[V]shift\f[R] and not \f[V]shift N\f[R]
for multiple parameters.
.IP \[bu] 2
\f[I]OFF\f[R]: Use \f[V]shift N\f[R].
.IP \[bu] 2
\f[I]ON\f[R]: Use only \f[V]shift\f[R].
.IP \[bu] 2
Multi-parameter \f[V]shift\f[R] is faster but may not be supported by
all implementations
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_CONFIG_NO_EXPR_BRE_MATCH\f[R]
.IP \[bu] 2
Suite: \f[V]BETTER_SCRIPTS_CONFIG_NO_EXPR_BRE_MATCH\f[R]
.IP \[bu] 2
Type: FLAG
.IP \[bu] 2
Class: CONSTANT
.IP \[bu] 2
Default: <automatic>
.IP \[bu] 2
[Disable]/Enable using alternatives to \f[V]expr\f[R] for matching a
\[lq]Basic Regular Expression
(\f[I]BRE\f[R])\[rq] (https://pubs.opengroup.org/onlinepubs/9699919799.2008edition/basedefs/V1_chap09.html#tag_09_03).
.IP \[bu] 2
\f[I]OFF\f[R]: Use \f[V]expr\f[R].
.IP \[bu] 2
\f[I]ON\f[R]: Use an alternative command (i.e.\ \f[V]sed\f[R]).
.IP \[bu] 2
\f[V]expr\f[R] is much faster if it works correctly, but some
implementations make that difficult, while \f[V]sed\f[R] is more robust
for this use case.
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_CONFIG_NO_DEV_NULL\f[R]
.IP \[bu] 2
Suite: \f[V]BETTER_SCRIPTS_CONFIG_NO_DEV_NULL\f[R]
.IP \[bu] 2
Type: FLAG
.IP \[bu] 2
Class: CONSTANT
.IP \[bu] 2
Default: <automatic>
.IP \[bu] 2
[Disable]/Enable using alternatives to \f[V]/dev/null\f[R] as a
redirection source/target (e.g.\ for output suppression).
.IP \[bu] 2
\f[I]OFF\f[R]: Use \f[V]/dev/null\f[R].
.IP \[bu] 2
\f[I]ON\f[R]: Use an alternative to \f[V]/dev/null\f[R].
.IP \[bu] 2
Using \f[V]/dev/null\f[R] as a redirection target is a common idiom, but
not always possible (e.g.
restricted shells generally forbid this), the alternative is to capture
output (and ignore it) but this is much slower as it involves a
subshell.
.SS USER PREFERENCE
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_CONFIG_QUIET_ERRORS\f[R]
.IP \[bu] 2
Suite: \f[V]BETTER_SCRIPTS_CONFIG_QUIET_ERRORS\f[R]
.IP \[bu] 2
Type: FLAG
.IP \[bu] 2
Class: VARIABLE
.IP \[bu] 2
Default: \f[I]OFF\f[R]
.IP \[bu] 2
[Enable]/Disable library error message output.
.IP \[bu] 2
\f[I]OFF\f[R]: error messages will be written to \f[V]STDERR\f[R] as:
\f[V][libarray::<COMMAND>]: ERROR: <MESSAGE>\f[R].
.IP \[bu] 2
\f[I]ON\f[R]: library error messages will be suppressed.
.IP \[bu] 2
The most recent error message is always available in
\f[V]BS_LIBARRAY_LAST_ERROR\f[R] even when error output is suppressed.
.IP \[bu] 2
Both the library version of this option and the suite version can be
modified between command invocations and will affect the next command.
.IP \[bu] 2
Does NOT affect errors from non-library commands, which \f[I]may\f[R]
still produce output.
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_CONFIG_FATAL_ERRORS\f[R]
.IP \[bu] 2
Suite: \f[V]BETTER_SCRIPTS_CONFIG_FATAL_ERRORS\f[R]
.IP \[bu] 2
Type: FLAG
.IP \[bu] 2
Class: VARIABLE
.IP \[bu] 2
Default: \f[I]OFF\f[R]
.IP \[bu] 2
Enable/[Disable] causing library errors to terminate the current
(sub-)shell.
.IP \[bu] 2
\f[I]OFF\f[R]: errors stop any further processing, and cause a non-zero
exit status, but do not cause an exception.
.IP \[bu] 2
\f[I]ON\f[R]: any library error will cause an \[lq]unset variable\[rq]
shell exception using the
\f[V]${parameter:?[word]}\f[R] (https://pubs.opengroup.org/onlinepubs/9699919799.2008edition/utilities/V3_chap02.html#tag_18_06_02)
parameter expansion, where \f[V]word\f[R] is set to an error message
that \f[I]should\f[R] be displayed by the shell (this message is NOT
suppressed by \f[V]BS_LIBARRAY_CONFIG_QUIET_ERRORS\f[R]).
.IP \[bu] 2
Both the library version of this option and the suite version can be
modified between command invocations and will affect the next command.
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_CONFIG_START_INDEX_ONE\f[R]
.IP \[bu] 2
Type: FLAG
.IP \[bu] 2
Class: CONSTANT
.IP \[bu] 2
Default: \f[I]OFF\f[R]
.IP \[bu] 2
Enable/[Disable] one-based indexing.
.IP \[bu] 2
\f[I]OFF\f[R]: use \f[V]0\f[R] (\f[V]<zero>\f[R]) based array indexes
(i.e.
in the range \f[V][0, size)\f[R]).
.IP \[bu] 2
\f[I]ON\f[R]: use \f[V]1\f[R] (\f[V]<one>\f[R]) based array indexes
(i.e.
in the range \f[V][1, size]\f[R]).
.IP \[bu] 2
Only affects commands that use indexes, i.e.
\f[V]array_get\f[R], \f[V]array_set\f[R], \f[V]array_remove\f[R],
\f[V]array_insert\f[R], and \f[V]array_slice\f[R]
.IP \[bu] 2
Negative indexes are \f[B]not\f[R] affected \f[V]-1\f[R] is
\f[B]always\f[R] the last element in the array.
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_CONFIG_FIND_REDIRECT_FD_1\f[R]
.IP \[bu] 2
Type: TEXT
.IP \[bu] 2
Class: CONSTANT
.IP \[bu] 2
Default: 3
.IP \[bu] 2
Used by \f[V]array_from_find_allow_print\f[R] as the first of two file
descriptors to use to redirect output.
.IP \[bu] 2
MUST be a single digit integer in the range [3,9] (the standard allows
for multiple digit file descriptors, but only \f[I]requires\f[R] (and
most implementations only support) single digits)
.IP \[bu] 2
When the given descriptor is used if it is already in use with a
previous (non-library) command this \f[I]will\f[R] cause errors.
.IP \[bu] 2
MUST be different to \f[V]BS_LIBARRAY_CONFIG_FIND_REDIRECT_FD_2\f[R]
.IP \[bu] 2
An invalid value will cause a fatal error while \f[B]sourcing\f[R].
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_CONFIG_FIND_REDIRECT_FD_2\f[R]
.IP \[bu] 2
Type: TEXT
.IP \[bu] 2
Class: CONSTANT
.IP \[bu] 2
Default: 4
.IP \[bu] 2
Used by \f[V]array_from_find_allow_print\f[R] as the second of two file
descriptors to use to redirect output.
.IP \[bu] 2
MUST be a single digit integer in the range [3,9] (the standard allows
for multiple digit file descriptors, but only \f[I]requires\f[R] (and
most implementations only support) single digits)
.IP \[bu] 2
When the given descriptor is used if it is already in use with a
previous (non-library) command this \f[I]will\f[R] cause errors.
.IP \[bu] 2
MUST be different to \f[V]BS_LIBARRAY_CONFIG_FIND_REDIRECT_FD_1\f[R]
.IP \[bu] 2
An invalid value will cause a fatal error while \f[B]sourcing\f[R].
.SS INFORMATIONAL
.PP
Variables that convey library information.
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_VERSION_MAJOR\f[R]
.IP \[bu] 2
Integer >= 1.
.IP \[bu] 2
Incremented when there are significant changes, or any changes break
compatibility with previous versions.
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_VERSION_MINOR\f[R]
.IP \[bu] 2
Integer >= 0.
.IP \[bu] 2
Incremented for significant changes that do not break compatibility with
previous versions.
.IP \[bu] 2
Reset to 0 when \f[V]BS_LIBARRAY_VERSION_MAJOR\f[R] changes.
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_VERSION_PATCH\f[R]
.IP \[bu] 2
Integer >= 0.
.IP \[bu] 2
Incremented for minor revisions or bugfixes.
.IP \[bu] 2
Reset to 0 when \f[V]BS_LIBARRAY_VERSION_MINOR\f[R] changes.
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_VERSION_RELEASE\f[R]
.IP \[bu] 2
A string indicating a pre-release version, always null for full-release
versions.
.IP \[bu] 2
Possible values include `alpha', `beta', `rc', etc, (a numerical suffix
may also be appended).
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_VERSION_FULL\f[R]
.IP \[bu] 2
Full version combining \f[V]BS_LIBARRAY_VERSION_MAJOR\f[R],
\f[V]BS_LIBARRAY_VERSION_MINOR\f[R], and
\f[V]BS_LIBARRAY_VERSION_PATCH\f[R] as a single integer.
.IP \[bu] 2
Can be used in numerical comparisons
.IP \[bu] 2
Format: \f[V]MNNNPPP\f[R] where, \f[V]M\f[R] is the \f[V]MAJOR\f[R]
version, \f[V]NNN\f[R] is the \f[V]MINOR\f[R] version (3 digit, zero
padded), and \f[V]PPP\f[R] is the \f[V]PATCH\f[R] version (3 digit, zero
padded).
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_VERSION\f[R]
.IP \[bu] 2
Full version combining \f[V]BS_LIBARRAY_VERSION_MAJOR\f[R],
\f[V]BS_LIBARRAY_VERSION_MINOR\f[R],
\f[V]BS_LIBARRAY_VERSION_PATCH\f[R], and
\f[V]BS_LIBARRAY_VERSION_RELEASE\f[R] as a formatted string.
.IP \[bu] 2
Format:
\f[V]BetterScripts \[aq]libarray\[aq] vMAJOR.MINOR.PATCH[-RELEASE]\f[R]
.IP \[bu] 2
Derived tools MUST include unique identifying information in this value
that differentiates them from the BetterScripts versions.
(This information should precede the version number.)
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_SH_TO_ARRAY\f[R]
.IP \[bu] 2
Contains a shell script which can be used with \f[V]sh -c\f[R] (or any
compliant shell) to create an array from the arguments passed to the
shell.
.IP \[bu] 2
Primarily designed to be used with \f[V]find -exec\f[R] to output an
array:
.RS 2
.IP
.nf
\f[C]
find \[dq]${PWD}\[dq] -exec sh -c \[rs]
  \[dq]${BS_LIBARRAY_SH_TO_ARRAY}\[dq] \[rs]
  BS_LIBARRAY_SH_TO_ARRAY -- \[aq]{}\[aq] \[aq]+\[aq]
echo \[aq] \[aq] #< This is required
\f[R]
.fi
.RE
.IP \[bu] 2
The array MUST have whitespace appended once it is generated or it will
fail to work as expected.
.IP \[bu] 2
\f[I]POSIX.1\f[R] specifies that the first argument following the script
is interpreted as the \[lq]command name\[rq] (and is used for
\f[V]$0\f[R] inside the script).
.IP \[bu] 2
Used internally by \f[V]array_from_find\f[R] and
\f[V]array_from_find_allow_print\f[R].
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_LAST_ERROR\f[R]
.IP \[bu] 2
Stores the error message of the most recent error.
.IP \[bu] 2
ONLY valid immediately following a command for which the exit status is
not \f[V]0\f[R] (\f[V]<zero>\f[R]).
.IP \[bu] 2
Available even when error output is suppressed.
.PP
   *   *   *   *   *
.SS \f[V]BS_LIBARRAY_SOURCED\f[R]
.IP \[bu] 2
Set (and non-null) once the library has been sourced.
.IP \[bu] 2
Dependant scripts can query if this variable is set to determine if this
file has been sourced.
.SS COMMANDS
.PP
   *   *   *   *   *
.SS \f[V]array_value\f[R]
.PP
Create a single array element from a given value.
.PP
Primarily for internal use, but may be of use should the normal array
creation commands not be suitable in a given situation.
.PP
Should \f[B]not\f[R] be used for values then passed to other commands
for adding to arrays.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_value <VALUE>
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]VALUE\f[R] [in]
Value to convert into an array value.
Can be null.
Can contain any arbitrary text excluding any embedded \f[V]\[rs]0\f[R]
(\f[V]<NUL>\f[R]) characters.
MUST be a single value.
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
ArrayValue=\[dq]$(array_value \[aq]Value\[aq])\[dq]
Array=\[dq]$(
  for ArrayValue in \[dq]$\[at]\[dq]
  do
    array_value \[dq]$ArrayValue\[dq]
  done
  echo \[aq] \[aq]
)\[dq]
\f[R]
.fi
.PP
   *   *   *   *   *
.SS \f[V]array_new\f[R]
.PP
Create a new named array from the given arguments \f[I]or\f[R] an array
written to \f[V]STDOUT\f[R] with values from \f[V]STDIN\f[R].
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
\&... | array_new

array_new [--reverse|--reversed|-r] <ARRAY> [<VALUE>...]
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]--reverse\f[R], \f[V]--reversed\f[R], \f[V]-r\f[R] [in]
Create the array in reverse order, first \f[V]VALUE\f[R] will be the
last array element, etc.
Can \f[I]not\f[R] be used for arrays created from \f[V]STDIN\f[R].
.TP
\f[V]ARRAY\f[R] [out:ref]
Variable that will contain the new array.
Any current contents will be lost.
MUST be a valid \f[I]POSIX.1\f[R] name or a \f[V]-\f[R]
(\f[V]<hyphen>\f[R]).
If specified as \f[V]-\f[R] (\f[V]<hyphen>\f[R]) array is written to
\f[V]STDOUT\f[R].
REQUIRED if \f[I]any\f[R] other argument is specified.
.TP
\f[V]VALUE\f[R] [in]
Can be specified multiple times.
Can be null.
Can contain any arbitrary text excluding any embedded \f[V]\[rs]0\f[R]
(\f[V]<NUL>\f[R]) characters.
Each value specified will become an array element.
.PP
If \f[V]ARRAY\f[R] is specified but \f[I]no\f[R] \f[V]VALUE\f[R]s are
specified an empty array is created.
.PP
If no arguments are provided input is from \f[V]STDIN\f[R] and array is
written to \f[V]STDOUT\f[R].
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
Array=\[dq]$(grep -e \[aq]ERROR\[aq] /var/log/syslog | array_new)\[dq]
Array=\[dq]$(array_new - \[dq]$Value1\[dq] ... \[dq]$ValueN\[dq])\[dq]
array_new \[aq]Array\[aq] \[dq]$Value1\[dq] ... \[dq]$ValueN\[dq]
array_new --reverse \[aq]Array\[aq] \[dq]$\[at]\[dq]

array_new \[aq]Array\[aq] \[dq]$\[at]\[dq]
\&...
eval \[dq]set -- ${Array}\[dq]
for Value in \[dq]$\[at]\[dq]; do ...; done
\f[R]
.fi
.PP
\f[I]NOTES\f[R]
.IP \[bu] 2
When given no arguments, will read array values from \f[V]STDIN\f[R]; if
this is erroneously used without \f[V]STDIN\f[R] directed into the
command this will block indefinitely.
.IP \[bu] 2
An array created from \f[V]STDIN\f[R] will have one element per line of
input; if values need to contain embedded \f[V]<newline>\f[R] characters
the array must be created with arguments.
.IP \[bu] 2
An empty array created when \f[I]only\f[R] \f[V]ARRAY\f[R] is specified
will result in \f[V]ARRAY\f[R] being set to null.
.IP \[bu] 2
An empty array created when \f[I]no\f[R] arguments are specified
(i.e.\ an empty array from a pipe/\f[V]STDIN\f[R]) will \f[B]ALWAYS\f[R]
contain at least whitespace, i.e.\ any variable set to the captured
output will \f[B]NOT\f[R] be null even if the array is empty.
To test for an empty array in this case use \f[V]array_size\f[R].
.IP \[bu] 2
Creating a reverse array is slower than a normal array, though the
difference is unlikely to be measurable in most cases.
.PP
   *   *   *   *   *
.SS \f[V]array_size\f[R]
.PP
Get the size of the given array.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_size <ARRAY> [<OUTPUT>]
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [in:ref]
Variable containing an array.
MUST be a valid \f[I]POSIX.1\f[R] name.
Can reference an empty array or \f[V]unset\f[R] variable.
.TP
\f[V]OUTPUT\f[R] [out:ref]
Variable that will contain the array size.
MUST be a valid \f[I]POSIX.1\f[R] name.
Any current contents will be lost.
If not specified, or specified as \f[V]-\f[R] (\f[V]<hyphen>\f[R]) size
is written to \f[V]STDOUT\f[R].
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
Size=\[dq]$(array_size \[aq]Array\[aq])\[dq]
Size=\[dq]$(array_size \[aq]Array\[aq] -)\[dq]
array_size \[aq]Array\[aq] \[aq]Size\[aq]
\f[R]
.fi
.PP
   *   *   *   *   *
.SS \f[V]array_get\f[R]
.PP
Look up an array value by index.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_get <ARRAY> <INDEX> [<OUTPUT>]
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [in:ref]
Variable containing an array.
MUST be a valid \f[I]POSIX.1\f[R] name.
MUST be an existing array of size > \f[V]INDEX\f[R].
.TP
\f[V]INDEX\f[R] [in]
Array index.
MUST be numeric.
MUST be within array bounds.
.TP
\f[V]OUTPUT\f[R] [out:ref]
Variable that will contain the element value.
Any current contents will be lost.
MUST be a valid \f[I]POSIX.1\f[R] name or a \f[V]-\f[R]
(\f[V]<hyphen>\f[R]).
If not specified, or specified as \f[V]-\f[R] (\f[V]<hyphen>\f[R]) value
is written to \f[V]STDOUT\f[R].
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
array_get \[aq]Array\[aq] 4 \[aq]ValueVar\[aq]
ValueVar=\[dq]$(array_get \[aq]Array\[aq] 4)\[dq]
ValueVar=\[dq]$(array_get \[aq]Array\[aq] 4 -)\[dq]
\f[R]
.fi
.PP
\f[I]NOTES\f[R]
.IP \[bu] 2
Supports zero-based, one-based, or negative indexing (see
\f[V]BS_LIBARRAY_CONFIG_START_INDEX_ONE\f[R]).
.IP \[bu] 2
If value is output to \f[V]STDOUT\f[R] data \f[I]may\f[R] be lost if the
array value ends with a \f[V]\[rs]n\f[R] (\f[V]<newline>\f[R])
(\f[I]POSIX.1\f[R] rules state that newlines should be removed from the
end of output generated by commands).
.PP
   *   *   *   *   *
.SS \f[V]array_set\f[R]
.PP
Set an array value by index.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_set <ARRAY> <INDEX> <VALUE>
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [in/out:ref]
Variable containing an array.
MUST be a valid \f[I]POSIX.1\f[R] name.
MUST be an existing array of size > \f[V]INDEX\f[R].
.TP
\f[V]INDEX\f[R] [in]
Array index.
MUST be numeric.
MUST be within array bounds.
.TP
\f[V]VALUE\f[R] [in]
Can be null.
Can contain any arbitrary text excluding any embedded \f[V]\[rs]0\f[R]
(\f[V]<NUL>\f[R]) characters.
MUST be a single value.
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
array_set \[aq]Array\[aq] 4 \[aq]New Value\[aq]
\f[R]
.fi
.PP
\f[I]NOTES\f[R]
.IP \[bu] 2
Supports zero-based, one-based, or negative indexing (see
\f[V]BS_LIBARRAY_CONFIG_START_INDEX_ONE\f[R]).
.PP
   *   *   *   *   *
.SS \f[V]array_insert\f[R]
.PP
Insert one or more values into an existing array.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_insert <ARRAY> <INDEX> <VALUE>...
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [in/out:ref]
Variable containing an array.
MUST be a valid \f[I]POSIX.1\f[R] name.
Can reference an empty array or \f[V]unset\f[R] variable (a new array
will be created).
.TP
\f[V]INDEX\f[R] [in]
Array index of first inserted element.
MUST be numeric.
MUST be within array bounds.
.TP
\f[V]VALUE\f[R] [in]
Can be specified multiple times.
Can be null.
Can contain any arbitrary text excluding any embedded \f[V]\[rs]0\f[R]
(\f[V]<NUL>\f[R]) characters.
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
array_insert \[aq]Array\[aq] 4 \[aq]Inserted Value\[aq] \[aq]Another Inserted Value\[aq]
\f[R]
.fi
.PP
\f[I]NOTES\f[R]
.IP \[bu] 2
Supports zero-based, one-based, or negative indexing (see
\f[V]BS_LIBARRAY_CONFIG_START_INDEX_ONE\f[R]).
.PP
   *   *   *   *   *
.SS \f[V]array_remove\f[R]
.PP
Remove one or more values from an existing array, by index, range, or
matching an expression.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_remove <ARRAY> <INDEX>

array_remove <ARRAY> <RANGE>

array_remove <ARRAY> <PRIMARY> <EXPRESSION>
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [in/out:ref]
Variable containing an array.
MUST be a valid \f[I]POSIX.1\f[R] name.
MUST be an existing array of size >= 1.
.TP
\f[V]INDEX\f[R] [in]
Array index.
MUST be numeric.
MUST be within array bounds.
.TP
\f[V]RANGE\f[R] [in]
A range within the array specified as either: \f[V][START]:[END]\f[R] or
\f[V][START]#[LENGTH]\f[R] where START and END are array indexes in the
range [START, END), and LENGTH is the count of elements in the range.
If LENGTH is negative or START is greater than END the range is a
reverse range.
If START is omitted, the range will begin with the first element of the
array.
If END or LENGTH are omitted, the range will end at the last element of
the array.
All elements MUST be within array bounds.
MUST contain at least the character \f[V]:\f[R] (\f[V]<colon>\f[R]) or
\f[V]#\f[R] (\f[V]<number-sign>\f[R]).
MUST result in a range of size >= 1.
.TP
\f[V]PRIMARY\f[R] [in]
A test operator used with EXPRESSION.
MUST be ONE of: \f[V]=\f[R], \f[V]!=\f[R], \f[V]-eq\f[R], \f[V]-ne\f[R],
\f[V]-gt\f[R], \f[V]-ge\f[R], \f[V]-lt\f[R], \f[V]-le\f[R],
\f[V]-like\f[R], or \f[V]-notlike\f[R].
The primaries \f[V]-gt\f[R], \f[V]-ge\f[R], \f[V]-lt\f[R], and
\f[V]-le\f[R] are identical to the \f[V]test\f[R] primaries of the same
names, while \f[V]=\f[R], \f[V]!=\f[R], \f[V]-eq\f[R], and \f[V]-ne\f[R]
are functionally similar, but do not distinguish between numerical and
string values.
The \f[V]-like\f[R] primary performs a \f[V]case\f[R] pattern match and
supports the glob characters as supported by \f[V]case\f[R], the
\f[V]-notlike\f[R] primary is identical, but with inverted meaning.
\f[V]-like\f[R] and \f[V]-notlike\f[R] support the normal \f[V]case\f[R]
pattern matching characters, and can consist of multiple patterns
delimited by the \f[V]|\f[R] character.
.TP
\f[V]EXPRESSION\f[R] [in]
Value to use with \f[V]PRIMARY\f[R].
Can be null.
\f[I]EXPECTS\f[R] - a \f[I]string\f[R] when \f[V]PRIMARY\f[R] is
\f[V]=\f[R] or \f[V]!=\f[R] - a \f[I]number\f[R] when \f[V]PRIMARY\f[R]
is \f[V]-eq\f[R], \f[V]-ne\f[R], \f[V]-gt\f[R], \f[V]-ge\f[R],
\f[V]-lt\f[R], or \f[V]-le\f[R] - a \f[V]case\f[R] pattern when
\f[V]PRIMARY\f[R] is \f[V]-like\f[R] or \f[V]-notlike\f[R].
\f[I]ALLOWS\f[R] - a \f[I]number\f[R] when \f[V]PRIMARY\f[R] is
\f[V]=\f[R] or \f[V]!=\f[R] - a \f[I]string\f[R] when \f[V]PRIMARY\f[R]
is \f[V]-eq\f[R] or \f[V]-ne\f[R].
\f[V]case\f[R] pattern allows the normal \f[V]case\f[R] pattern matching
characters: \f[V]*\f[R] (\f[V]<asterisk>\f[R]) \f[V]?\f[R]
(\f[V]<question-mark>\f[R]), and \f[V][\f[R]
(\f[V]<left-square-bracket>\f[R]) with the same meanings as with a
standard \f[V]case\f[R] match; also supported is the pattern delimiter
\f[V]|\f[R] (\f[V]<vertical-line>\f[R]) which can be used to separate
multiple patterns in a single \f[V]EXPRESSION\f[R].
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
array_remove \[aq]Array\[aq] 2
array_remove \[aq]Array\[aq] \[aq]4:7\[aq]
array_remove \[aq]Array\[aq] -like \[aq]*an error*|*a warning*\[aq]
array_remove \[aq]Array\[aq] -notlike \[aq]*an error*|*a warning*\[aq]
\f[R]
.fi
.PP
   *   *   *   *   *
.SS \f[V]array_push\f[R]
.PP
Add one or more values to the end of an array.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_push <ARRAY> [<VALUE>...]
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [in/out:ref]
Variable containing an array.
MUST be a valid \f[I]POSIX.1\f[R] name.
Can reference an empty array or \f[V]unset\f[R] variable (a new array
will be created).
.TP
\f[V]VALUE\f[R] [in]
Can be specified multiple times.
Can be null.
Can contain any arbitrary text excluding any embedded \f[V]\[rs]0\f[R]
(\f[V]<NUL>\f[R]) characters.
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
array_push \[aq]Array\[aq] \[aq]Pushed Value 1\[aq] ... \[aq]Pushed Value N\[aq]
array_push \[aq]Array\[aq] \[dq]$\[at]\[dq]
\f[R]
.fi
.PP
\f[I]NOTES\f[R]
.IP \[bu] 2
If no VALUEs are specified, no modification is made to \f[V]ARRAY\f[R].
.IP \[bu] 2
Performance of \f[V]array_push\f[R], \f[V]array_unshift\f[R], and
\f[V]array_new\f[R] are not measurably different given the same input.
.PP
   *   *   *   *   *
.SS \f[V]array_pop\f[R]
.PP
Remove a single value from the back of an array and save it to a
variable.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_pop <ARRAY> <OUTPUT>
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [in/out:ref]
Variable containing an array.
MUST be a valid \f[I]POSIX.1\f[R] name.
MUST be an existing array of size >= 1.
.TP
\f[V]OUTPUT\f[R] [out:ref]
Variable that will contain the popped value.
Any current contents will be lost.
MUST be a valid \f[I]POSIX.1\f[R] name.
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
array_pop \[aq]Array\[aq] \[aq]ValueVar\[aq]
\f[R]
.fi
.PP
\f[I]NOTES\f[R]
.IP \[bu] 2
If popping results in an empty array the array variable will be set to
null.
.PP
   *   *   *   *   *
.SS \f[V]array_unshift\f[R]
.PP
Add one or more values to the front of an array.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_unshift <ARRAY> [<VALUE>...]
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [in/out:ref]
Variable containing an array.
MUST be a valid \f[I]POSIX.1\f[R] name.
Can reference an empty array or \f[V]unset\f[R] variable (a new array
will be created).
.TP
\f[V]VALUE\f[R] [in]
Can be specified multiple times.
Can be null.
Can contain any arbitrary text excluding any embedded \f[V]\[rs]0\f[R]
(\f[V]<NUL>\f[R]) characters.
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
array_unshift \[aq]Array\[aq] \[aq]Value 1\[aq] ... \[aq]Value N\[aq]
array_unshift \[aq]Array\[aq] \[dq]$\[at]\[dq]
\f[R]
.fi
.PP
\f[I]NOTES\f[R]
.IP \[bu] 2
If no VALUEs are specified, no modification is made to \f[V]ARRAY\f[R].
.IP \[bu] 2
Performance of \f[V]array_push\f[R], \f[V]array_unshift\f[R], and
\f[V]array_new\f[R] are not measurably different given the same input.
.PP
   *   *   *   *   *
.SS \f[V]array_shift\f[R]
.PP
Remove a single value from the front of an array and save it to a
variable.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_shift <ARRAY> <OUTPUT>
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [in/out:ref]
Variable containing an array.
MUST be a valid \f[I]POSIX.1\f[R] name.
MUST be an existing array of size >= 1.
.TP
\f[V]OUTPUT\f[R] [out:ref]
Variable that will contain the shifted value.
Any current contents will be lost.
MUST be a valid \f[I]POSIX.1\f[R] name.
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
array_shift \[aq]Array\[aq] \[aq]ValueVar\[aq]
\f[R]
.fi
.PP
\f[I]NOTES\f[R]
.IP \[bu] 2
If shifting results in an empty array the array variable will be set to
null
.PP
   *   *   *   *   *
.SS \f[V]array_reverse\f[R]
.PP
Reverse the elements of an array.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_reverse <ARRAY> [<OUTPUT>]
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [in/out:ref]
Variable containing an array.
MUST be a valid \f[I]POSIX.1\f[R] name.
Can reference an empty array or \f[V]unset\f[R] variable.
.TP
\f[V]OUTPUT\f[R] [out:ref]
Variable that will contain the reversed array.
Any current contents will be lost.
MUST be a valid \f[I]POSIX.1\f[R] name or a \f[V]-\f[R]
(\f[V]<hyphen>\f[R]).
If specified as \f[V]-\f[R] (\f[V]<hyphen>\f[R]) reversed array is
written to \f[V]STDOUT\f[R].
If not specified the array is reversed in-place (i.e.\ the input array
is also the output array).
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
array_reverse \[aq]Array\[aq]
array_reverse \[aq]Array\[aq] \[aq]ReversedArrayVar\[aq]
ReversedArrayVar=\[dq]$(array_reverse \[aq]Array\[aq] -)\[dq]
\f[R]
.fi
.PP
   *   *   *   *   *
.SS \f[V]array_slice\f[R]
.PP
Get a slice of an existing array.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_slice <ARRAY> <RANGE> [<OUTPUT>]
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [in:ref]
Variable containing an array.
MUST be a valid \f[I]POSIX.1\f[R] name.
MUST be an existing array of size >= 1.
.TP
\f[V]RANGE\f[R] [in]
A range within the array specified as either: \f[V][START]:[END]\f[R] or
\f[V][START]#[LENGTH]\f[R] where START and END are array indexes in the
range [START, END), and LENGTH is the count of elements in the range.
If LENGTH is negative or START is greater than END the range is a
reverse range.
If START is omitted, the range will begin with the first element of the
array.
If END or LENGTH are omitted, the range will end at the last element of
the array.
All elements MUST be within array bounds.
MUST contain at least the character \f[V]:\f[R] (\f[V]<colon>\f[R]) or
\f[V]#\f[R] (\f[V]<number-sign>\f[R]).
MUST result in a range of size >= 1.
.TP
\f[V]OUTPUT\f[R] [out:ref]
Variable that will contain the array slice.
Any current contents will be lost.
MUST be a valid \f[I]POSIX.1\f[R] name or a \f[V]-\f[R]
(\f[V]<hyphen>\f[R]).
If not specified, or specified as \f[V]-\f[R] (\f[V]<hyphen>\f[R]) array
slice is written to \f[V]STDOUT\f[R].
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
array_slice \[aq]Array\[aq] \[aq]2:4\[aq]  \[aq]SlicedArrayVar\[aq]
array_slice \[aq]Array\[aq] \[aq]:2\[aq]   \[aq]SlicedArrayVar\[aq]
array_slice \[aq]Array\[aq] \[aq]2#2\[aq]  \[aq]SlicedArrayVar\[aq]
array_slice \[aq]Array\[aq] \[aq]4:2\[aq]  \[aq]SlicedArrayVar\[aq]
array_slice \[aq]Array\[aq] \[aq]4#-2\[aq] \[aq]SlicedArrayVar\[aq]
\f[R]
.fi
.PP
NOTES:
.IP \[bu] 2
Supports zero-based, one-based, or negative indexing (see
\f[V]BS_LIBARRAY_CONFIG_START_INDEX_ONE\f[R]).
.PP
   *   *   *   *   *
.SS \f[V]array_sort\f[R]
.PP
Sort an array.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_sort <ARRAY> [<OUTPUT>] [--] [<ARGUMENT>...]
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [in/out:ref]
Variable containing an array.
MUST be a valid \f[I]POSIX.1\f[R] name.
Can reference an empty array or \f[V]unset\f[R] variable.
.TP
\f[V]OUTPUT\f[R] [out:ref]
Variable that will contain the sorted array.
Any current contents will be lost.
MUST be a valid \f[I]POSIX.1\f[R] name or a \f[V]-\f[R]
(\f[V]<hyphen>\f[R]).
If specified as \f[V]-\f[R] (\f[V]<hyphen>\f[R]) sorted array is written
to \f[V]STDOUT\f[R].
If not specified array is sorted \[lq]in-place\[rq].
.TP
\f[V]--\f[R] [in]
Causes all remaining arguments to be interpreted as arguments for
\f[V]sort\f[R].
REQUIRED if \f[V]OUTPUT\f[R] is \f[I]not\f[R] specified and the first
argument to \f[V]sort\f[R] does \f[I]not\f[R] being with a
\f[V]<hyphen>\f[R].
.TP
\f[V]ARGUMENT\f[R] [in]
Can be specified multiple times.
All values passed directly to \f[V]sort\f[R].
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
array_sort \[aq]Array\[aq] -r
array_sort \[aq]Array\[aq] -- -r
array_sort \[aq]Array\[aq] \[aq]SortedArrayVar\[aq] -r
SortedArrayVar=\[dq]$(array_sort \[aq]Array\[aq] - -r)\[dq]
\f[R]
.fi
.PP
\f[I]NOTES\f[R]
.IP \[bu] 2
Because \f[V]sort\f[R] works on lines, values containing
\f[V]<newline>\f[R] characters have to be modified to be a single line.
This \f[I]will\f[R] affect sort order in some cases (i.e.\ the output
may \f[I]not\f[R] be strictly lexicographically correct with regards to
any embedded \f[V]<newline>\f[R] characters), however the sort order of
these values \f[I]will\f[R] be stable.
.PP
   *   *   *   *   *
.SS \f[V]array_search\f[R]
.PP
Search an array for an element and get the index of that element.
.PP
Exit status will be zero \f[I]only\f[R] if a match was found, otherwise
it will be non-zero.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_search <ARRAY> [<INDEX>] [<PRIMARY>] <EXPRESSION>
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [in:ref]
Variable containing an array.
MUST be a valid \f[I]POSIX.1\f[R] name.
Can reference an empty array or \f[V]unset\f[R] variable.
.TP
\f[V]INDEX\f[R] [in/out:ref]
Variable which will contain the index of the found element, or will be
set to null otherwise.
Any current contents will be lost.
MUST be a valid \f[I]POSIX.1\f[R] name or a \f[V]-\f[R]
(\f[V]<hyphen>\f[R]).
If not specified, or specified as \f[V]-\f[R] (\f[V]<hyphen>\f[R]) index
is written to \f[V]STDOUT\f[R].
If the variable specified is \f[I]not\f[R] null, the value is used as an
offset from which the search should begin.
.TP
\f[V]PRIMARY\f[R] [in]
A test operator used with EXPRESSION.
MUST be ONE of: \f[V]=\f[R], \f[V]!=\f[R], \f[V]-eq\f[R], \f[V]-ne\f[R],
\f[V]-gt\f[R], \f[V]-ge\f[R], \f[V]-lt\f[R], \f[V]-le\f[R],
\f[V]-like\f[R], or \f[V]-notlike\f[R].
The primaries \f[V]-gt\f[R], \f[V]-ge\f[R], \f[V]-lt\f[R], and
\f[V]-le\f[R] are identical to the \f[V]test\f[R] primaries of the same
names, while \f[V]=\f[R], \f[V]!=\f[R], \f[V]-eq\f[R], and \f[V]-ne\f[R]
are functionally similar, but do not distinguish between numerical and
string values.
The \f[V]-like\f[R] primary performs a \f[V]case\f[R] pattern match and
supports the glob characters as supported by \f[V]case\f[R], the
\f[V]-notlike\f[R] primary is identical, but with inverted meaning.
\f[V]-like\f[R] and \f[V]-notlike\f[R] support the normal \f[V]case\f[R]
pattern matching characters, and can consist of multiple patterns
delimited by the \f[V]|\f[R] character.
If not specified the primary \f[V]=\f[R] is used.
.TP
\f[V]EXPRESSION\f[R] [in]
Value to use with PRIMARY.
Can be null.
\f[I]EXPECTS\f[R] - a \f[I]string\f[R] when PRIMARY is \f[V]=\f[R] or
\f[V]!=\f[R] - a \f[I]number\f[R] when PRIMARY is \f[V]-eq\f[R],
\f[V]-ne\f[R], \f[V]-gt\f[R], \f[V]-ge\f[R], \f[V]-lt\f[R], or
\f[V]-le\f[R] - a \f[V]case\f[R] pattern when PRIMARY is \f[V]-like\f[R]
or \f[V]-notlike\f[R].
\f[I]ALLOWS\f[R] - a \f[I]number\f[R] when PRIMARY is \f[V]=\f[R] or
\f[V]!=\f[R] - a \f[I]string\f[R] when PRIMARY is \f[V]-eq\f[R] or
\f[V]-ne\f[R].
\f[V]case\f[R] pattern allows the normal \f[V]case\f[R] pattern matching
characters: \f[V]*\f[R] (\f[V]<asterisk>\f[R]) \f[V]?\f[R]
(\f[V]<question-mark>\f[R]), and \f[V][\f[R]
(\f[V]<left-square-bracket>\f[R]) with the same meanings as with a
standard \f[V]case\f[R] match; also supported is the pattern delimiter
\f[V]|\f[R] (\f[V]<vertical-line>\f[R]) which can be used to separate
multiple patterns in a single \f[V]EXPRESSION\f[R].
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
while array_search \[aq]Array\[aq] \[aq]Location\[aq] -like \[aq]*an error*|*a warning*\[aq]
do
  ...
done
\f[R]
.fi
.PP
\f[I]NOTES\f[R]
.IP \[bu] 2
See \f[V]array_contains\f[R] for an alternative when INDEX is not
required.
.PP
   *   *   *   *   *
.SS \f[V]array_contains\f[R]
.PP
Identical to \f[V]array_search\f[R] except the index is not returned
(allowing this to be much faster when \f[V]PRIMARY\f[R] is \f[V]=\f[R],
\f[V]!=\f[R], \f[V]-eq\f[R], or \f[V]-ne\f[R]).
.PP
See \f[V]array_search\f[R] for more information.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_contains <ARRAY> [<PRIMARY>] <EXPRESSION>
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.PP
As for \f[V]array_search\f[R], with the exception of \f[V]INDEX\f[R]
(which is not supported).
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
if array_contains \[aq]Array\[aq] -like \[aq]*an error*|*a warning*\[aq]
then
  ...
fi
\f[R]
.fi
.PP
   *   *   *   *   *
.SS \f[V]array_join\f[R]
.PP
Join all array values into a single string.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_join <ARRAY> <DELIM> [<OUTPUT>]
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [in:ref]
Variable containing an array.
MUST be a valid \f[I]POSIX.1\f[R] name.
Can reference an empty array or \f[V]unset\f[R] variable.
.TP
\f[V]DELIM\f[R] [in]
Value used to delimit joined values.
Can be null.
Can contain any escape sequences that \f[V]printf\f[R] understands,
however \f[V]%\f[R] (\f[V]<percent-sign>\f[R]) characters will be output
literally.
.TP
\f[V]OUTPUT\f[R] [out:ref]
Variable that will contain the joined string.
Any current contents will be lost.
MUST be a valid \f[I]POSIX.1\f[R] name or a \f[V]-\f[R]
(\f[V]<hyphen>\f[R]).
If not specified, or specified as \f[V]-\f[R] (\f[V]<hyphen>\f[R])
joined string is written to \f[V]STDOUT\f[R].
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
array_join \[aq]Array\[aq] \[aq],\[aq] \[aq]JoinedTextVar\[aq]
JoinedTextVar=\[dq]$(array_join \[aq]Array\[aq] \[aq],\[aq])\[dq]
JoinedTextVar=\[dq]$(array_join \[aq]Array\[aq] \[aq],\[aq] -)\[dq]
\f[R]
.fi
.PP
\f[I]NOTES\f[R]
.IP \[bu] 2
If joined text is output to \f[V]STDOUT\f[R] data \f[I]may\f[R] be lost
if if the \f[I]last\f[R] array value ends with a \f[V]\[rs]n\f[R]
(\f[V]<newline>\f[R]) (\f[I]POSIX.1\f[R] rules state that newlines
should be removed from the end of output generated by commands).
.PP
   *   *   *   *   *
.SS \f[V]array_split\f[R]
.PP
Create an array by splitting text.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_split [<ARRAY>] <TEXT> <SEPARATOR>
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [out:ref]
Variable that will contain the new array.
Any current contents will be lost.
MUST be a valid \f[I]POSIX.1\f[R] name or a \f[V]-\f[R]
(\f[V]<hyphen>\f[R]).
If not specified, or specified as \f[V]-\f[R] (\f[V]<hyphen>\f[R])
joined string is written to \f[V]STDOUT\f[R].
.TP
\f[V]TEXT\f[R] [in]
Text to split into array elements.
Can be null.
Can contain any arbitrary text excluding any embedded \f[V]\[rs]0\f[R]
(\f[V]<NUL>\f[R]) characters.
.TP
\f[V]SEPARATOR\f[R] [in]
Expression used to split \f[V]TEXT\f[R].
Can contain any arbitrary text excluding any embedded \f[V]\[rs]0\f[R]
(\f[V]<NUL>\f[R]) characters.
Is interpreted as a \f[I]POSIX.1\f[R] \[lq]Extended Regular
Expression\[rq] (https://pubs.opengroup.org/onlinepubs/9699919799.2008edition/basedefs/V1_chap09.html#tag_09_04)
\f[I]unless\f[R] exactly \f[I]one\f[R] character when it is interpreted
literally.
Is used with the \f[V]awk\f[R] command \f[V]split\f[R].
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
array_split \[aq]Array\[aq] \[dq]$PATH\[dq] \[aq]:\[aq]
Array=\[dq]$(array_split \[dq]$PATH\[dq] \[aq]:\[aq])\[dq]
Array=\[dq]$(array_split - \[dq]$PATH\[dq] \[aq]:\[aq])\[dq]
\f[R]
.fi
.PP
\f[I]NOTES\f[R]
.IP \[bu] 2
The \f[V]awk\f[R] command \f[V]split\f[R] is used to split text, so both
\f[V]TEXT\f[R] and \f[V]SEPARATOR\f[R] are subject to the general
\f[V]awk\f[R] requirements and any specific \f[V]split\f[R]
requirements.
Whether or not \[lq]empty\[rq] elements are created, may also be
dependent on how \f[V]split\f[R] operates.
.IP \[bu] 2
If the separator text is intended to be a simple string longer than a
single character, any regular expression commands MUST be escaped.
Importantly, this includes \f[V].\f[R] (\f[V]<period>\f[R])) which will
match \f[B]any\f[R] character if not escaped.
.IP \[bu] 2
Requires \f[V]awk\f[R] supports the \f[V]ENVIRON\f[R] array which was
added in 1989, but is not part of the traditional \f[V]awk\f[R]
specification and may be omitted in some implementations.
(This is due to how strings are processed when passed to \f[V]awk\f[R]
as arguments: not only do these have to be escaped in ways that are hard
to do correctly, but they may not contain embedded newline characters.
The \f[V]ENVIRON\f[R] array has neither restriction.)
.PP
   *   *   *   *   *
.SS \f[V]array_printf\f[R]
.PP
Print each element of the array with the given format.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_printf <ARRAY> <FORMAT>
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [in:ref]
Variable containing an array.
MUST be a valid \f[I]POSIX.1\f[R] name.
MAY reference an empty array or \f[V]unset\f[R] variable.
.TP
\f[V]FORMAT\f[R] [in]
Passed directly to \f[V]printf\f[R].
Applied for each array element in turn.
SHOULD include a \f[V]%\f[R] (\f[V]<percent-sign>\f[R]) format code.
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
array_printf \[aq]Array\[aq] \[aq]Array Value: \[dq]%s\[dq]\[rs]n\[aq]
\f[R]
.fi
.PP
\f[I]NOTES\f[R]
.IP \[bu] 2
If \f[V]FORMAT\f[R] contains no format code, the literal string it
contains will be output once per element in \f[V]ARRAY\f[R].
.PP
   *   *   *   *   *
.SS \f[V]array_from_path\f[R]
.PP
Populate an array with the paths contained in the given path.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_from_path [--all|-a] [<ARRAY>] <PATH>
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]--all\f[R], \f[V]-a\f[R] [in]
Include \[lq]dot files\[rq] (aka \[lq]hidden files\[rq]).
Ignored if \f[V]PATH\f[R] is \f[I]not\f[R] a directory.
.TP
\f[V]ARRAY\f[R] [out:ref]
Variable that will contain the new array.
Any current contents will be lost.
MUST be a valid \f[I]POSIX.1\f[R] name or a \f[V]-\f[R]
(\f[V]<hyphen>\f[R]).
If not specified, or specified as \f[V]-\f[R] (\f[V]<hyphen>\f[R]) array
is written to \f[V]STDOUT\f[R].
.TP
\f[V]PATH\f[R] [in]
A valid path for the current platform.
Path MUST be suitable for appending a glob pattern.
Partial paths are permitted.
Interpreted literally (i.e.\ glob characters will not be used as glob
characters).
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
#< find /usr/local/share, /usr/local/sbin, etc
array_from_path \[aq]Array\[aq] /usr/local/s

#< find all paths in /usr/bin/
array_from_path --all \[aq]Array\[aq] /usr/bin
\f[R]
.fi
.PP
\f[I]NOTES\f[R]
.IP \[bu] 2
It is relatively straightforward to create an array from a shell glob
expression, however, there are a number of cases that can elicit
unexpected results and require special care (e.g.\ paths containing
special characters, globs for non-existing paths, etc).
Additionally, there are potential issues with specific platforms that
make it harder to write a truly portable solution than it seems.
.PP
   *   *   *   *   *
.SS \f[V]array_from_find\f[R]
.PP
Create an array from the results of the \f[V]find\f[R] command.
.PP
In contrast to \f[V]array_from_find_allow_print\f[R], this command
builds the array by capturing \f[V]STDOUT\f[R]; any output from
\f[V]find\f[R] that is sent to \f[V]STDOUT\f[R] \f[I]will\f[R] result in
broken array (the \f[V]-print\f[R] primary is explicitly checked for and
triggers an error if detected).
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_from_find [<ARRAY>] [--] [<ARGUMENT>...]
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [out:ref]
Variable that will contain the new array.
Any current contents will be lost.
MUST be a valid \f[I]POSIX.1\f[R] name or a \f[V]-\f[R]
(\f[V]<hyphen>\f[R]).
If not specified, or specified as \f[V]-\f[R] (\f[V]<hyphen>\f[R]) array
is written to \f[V]STDOUT\f[R].
.TP
\f[V]--\f[R] [in]
Causes all remaining arguments to be interpreted as arguments for
\f[V]find\f[R].
REQUIRED if ARRAY is \f[I]not\f[R] specified and the first argument to
\f[V]find\f[R] does \f[I]not\f[R] being with a \f[V]<hyphen>\f[R].
.TP
\f[V]ARGUMENT\f[R] [in]
Can be specified multiple times.
All values passed directly to \f[V]find\f[R].
Can include any values accepted by \f[V]find\f[R], including options
(e.g.\ \f[V]-H\f[R]), paths, and \f[B]most\f[R] \f[V]find\f[R]
primaries.
MUST \f[B]not\f[R] include any \f[V]find\f[R] primaries that write to
\f[V]STDOUT\f[R] (e.g.\ \f[V]-print\f[R]).
Expression created by using \f[V]find\f[R] primaries and operators
\f[I]may\f[R] need grouped into a \f[V]find\f[R] sub-expression (even
when this would not normally be required).
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
array_from_find \[aq]Array\[aq] -- -L \[dq]$PWD\[dq] \[aq](\[aq] -type f -o -type d \[aq])\[aq]
Array=\[dq]$(array_from_find - -L \[dq]$PWD\[dq] -type f)\[dq]
\f[R]
.fi
.PP
\f[I]NOTES\f[R]
.IP \[bu] 2
Implemented using \f[V]BS_LIBARRAY_SH_TO_ARRAY\f[R]
.IP \[bu] 2
Requires \f[V]sh\f[R] is an available command that can execute a simple
shell script with the \f[V]-c\f[R] option, as specified in the
\f[I]POSIX.1\f[R] standard.
.IP \[bu] 2
The array is built by appending an \f[V]-exec\f[R] primary to any passed
primaries, i.e.\ the array is built as a result of an implicit
\f[V]-a\f[R] where the left hand side being is whatever expression was
last in the list of primaries passed to the command.
This can result in unintended output when using the \f[V]-o\f[R]
primary, where properly grouping primaries (using \f[V](\f[R]
(\f[V]<left-parenthesis>\f[R]), and \f[V])\f[R]
(\f[V]<right-parenthesis>\f[R])) is essential.
.IP \[bu] 2
Some implementations of \f[V]find\f[R] allow it to be invoked without
any arguments, or with arguments but without any paths.
This is supported by this command if supported by the current platform.
.IP \[bu] 2
\f[V]array_from_find_allow_print\f[R] is provided if \f[V]find\f[R]
primaries that generate output are required.
.PP
   *   *   *   *   *
.SS \f[V]array_from_find_allow_print\f[R]
.PP
Create an array from the results of the \f[V]find\f[R] command.
.PP
Similar to \f[V]array_from_find\f[R] but builds the array using output
redirection instead of simply capturing \f[V]STDOUT\f[R] so any
\f[V]find\f[R] primary that emits data to \f[V]STDOUT\f[R]
(e.g.\ \f[V]-print\f[R]) can be used \f[I]in addition\f[R] to building
the array.
.PP
\f[I]SYNOPSIS\f[R]
.IP
.nf
\f[C]
array_from_find_allow_print <ARRAY> [<FD>] [--] [<ARGUMENT>...]
\f[R]
.fi
.PP
\f[I]ARGUMENTS\f[R]
.TP
\f[V]ARRAY\f[R] [out:ref]
Variable that will contain the new array.
Any current contents will be lost.
MUST be a valid \f[I]POSIX.1\f[R] name.
.TP
\f[V]FD\f[R] [in]
A pair of file descriptors in the form \f[V]<FD>,<FD>\f[R] where each
\f[V]FD\f[R] is a \f[I]different\f[R] single digit from the set
\f[V][3456789]\f[R].
If omitted values are taken from the configuration values
\f[V]BS_LIBARRAY_CONFIG_FIND_REDIRECT_FD_1\f[R] and
\f[V]BS_LIBARRAY_CONFIG_FIND_REDIRECT_FD_2\f[R].
.TP
\f[V]--\f[R] [in]
Causes all remaining arguments to be interpreted as arguments for
\f[V]find\f[R].
REQUIRED if \f[V]FD\f[R] is \f[I]not\f[R] specified and the first
argument to \f[V]find\f[R] looks like \f[V]FD\f[R].
.TP
\f[V]ARGUMENT\f[R] [in]
Can be specified multiple times.
All values passed directly to \f[V]find\f[R].
Can include any values accepted by \f[V]find\f[R], including options
(e.g.\ \f[V]-H\f[R]), paths, and \f[V]find\f[R] primaries.
Expression created by using \f[V]find\f[R] primaries and operators
\f[I]may\f[R] need grouped into a \f[V]find\f[R] sub-expression (even
when this would not normally be required).
.PP
\f[I]EXAMPLES\f[R]
.IP
.nf
\f[C]
# Find all broken links in the current directory tree
# and both store in an array AND print to STDOUT
array_from_find_allow_print \[aq]Array\[aq] 5,7 -- -L \[dq]$PWD\[dq] -type l -print
\f[R]
.fi
.PP
\f[I]NOTES\f[R]
.IP \[bu] 2
Implemented using \f[V]BS_LIBARRAY_SH_TO_ARRAY\f[R]
.IP \[bu] 2
Requires \f[V]sh\f[R] is an available command that can execute a simple
shell script with the \f[V]-c\f[R] option, as specified in the
\f[I]POSIX.1\f[R] standard.
.IP \[bu] 2
The array is built by appending an \f[V]-exec\f[R] primary to any passed
primaries, i.e.\ the array is built as a result of an implicit
\f[V]-a\f[R] where the left hand side being is whatever expression was
last in the list of primaries passed to the command.
This can result in unintended output when using the \f[V]-o\f[R]
primary, where properly grouping primaries (using \f[V](\f[R]
(\f[V]<left-parenthesis>\f[R]), and \f[V])\f[R]
(\f[V]<right-parenthesis>\f[R])) is essential.
.IP \[bu] 2
This is likely to be of limited use; capturing the output from the
\f[V]find\f[R] primaries would require a subshell meaning that the
generated array would \f[B]only\f[R] be available \f[I]within\f[R] that
subshell.
.IP \[bu] 2
To support output from \f[V]find\f[R] primaries and also generate an
array it is necessary to redirect output.
If the file descriptors used are already in use this \f[B]will\f[R]
cause errors.
.IP \[bu] 2
The \f[I]POSIX.1\f[R] standard \f[I]allows\f[R] for multi-digit file
descriptors, however only \f[I]requires\f[R] support for single-digit
descriptors and at least some common implementations do not support
multi-digit file descriptors, so they are not permitted for use here.
.SS STANDARDS
.IP \[bu] 2
\f[I]POSIX.1-2008\f[R] (https://pubs.opengroup.org/onlinepubs/9699919799.2008edition)
.RS 2
.IP \[bu] 2
also known as:
.RS 2
.IP \[bu] 2
\f[I]The Open Group Base Specifications Issue 7\f[R]
.IP \[bu] 2
\f[I]IEEE Std 1003.1-2008\f[R]
.IP \[bu] 2
\f[I]The Single UNIX Specification Version 4 (SUSv4)\f[R]
.RE
.IP \[bu] 2
the more recent
\f[I]POSIX.1-2017\f[R] (https://pubs.opengroup.org/onlinepubs/9699919799)
is functionally identical to \f[I]POSIX.1-2008\f[R], but incorporates
some errata
.RE
.IP \[bu] 2
FreeBSD SYSEXITS(3) (https://www.freebsd.org/cgi/man.cgi?sysexits(3))
.RS 2
.IP \[bu] 2
while not truly standard, these are used by many projects
.RE
.IP \[bu] 2
Semantic Versioning v2.0.0 (https://semver.org/)
.SS NOTES
.SS TERMINOLOGY
.IP \[bu] 2
An \f[I]array\f[R] contains zero or more \f[I]elements\f[R].
.IP \[bu] 2
Each \f[I]element\f[R] is any \f[I]value\f[R] that can be stored in a
standard shell variable, however:
.RS 2
.IP \[bu] 2
the \f[V]\[rs]0\f[R] (\f[V]<NUL>\f[R]) character is not supported
.IP \[bu] 2
support for any characters not appearing in the \f[I]POSIX\f[R] locale
is entirely dependent on the shell and utilities used
.RE
.IP \[bu] 2
A \f[I]value\f[R] may be \f[I]null\f[R], which is equivalent to the
empty string.
.RS 2
.IP \[bu] 2
a \f[I]null\f[R] \f[I]value\f[R] is different from a \f[V]<NUL>\f[R]
character
.RE
.IP \[bu] 2
Each \f[I]array\f[R] is stored in a single shell variable.
.IP \[bu] 2
An \f[I]array\f[R] is passed to a command by \f[I]reference\f[R], i.e.
the \f[B]name\f[R] of the \f[I]array\f[R] shell variable is passed to
commands, \f[B]not\f[R] the contents:
.RS 2
.IP
.nf
\f[C]
array_new  \[aq]Fibonacci\[aq] 0 1 1 2 3 5 #< New array stored in $Fibonacci
array_size \[aq]Fibonacci\[aq]             #< Outputs 6
\f[R]
.fi
.RE
.IP \[bu] 2
\f[I]Array\f[R] \f[I]elements\f[R] can be manipulated using the commands
in this library, or can be accessed using shell positional parameters
(i.e.\ \f[V]$\[at]\f[R], \f[V]$1\f[R], \f[V]$2\f[R], \&...)
by \f[I]unpacking\f[R] the \f[I]array\f[R] using:
.RS 2
.IP
.nf
\f[C]
array_new \[aq]Fibonacci\[aq] 0 1 1 2 3 5  #< New array stored in $Fibonacci
eval \[dq]set -- $Fibonacci\[dq]
print \[aq]%d\[rs]n\[aq] \[dq]$4\[dq]                  #< Outputs 2
\f[R]
.fi
.RE
.SS GENERAL
.IP \[bu] 2
General modification of an array outside of the library is not
supported, however arrays can be concatenated by appending the contents
of the array variables:
.RS 2
.IP
.nf
\f[C]
ArrayCat=\[dq]${ArrayOne}${ArrayTwo}\[dq]
\f[R]
.fi
.RE
.IP \[bu] 2
Argument validation occurs where possible and (relatively) performant
for all arguments to all commands.
.SS SEE ALSO
.PP
betterscripts(7)
.SH AUTHORS
BetterScripts (better.scripts\[at]proton.me).
